<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    #c1 {
      margin: 100px auto;
      border: 1px solid #ccc;
    }
  </style>
</head>

<body>
  <canvas id="c1" width="800" height="600">
    浏览器不支持canvas
  </canvas>
  <script>
    const canvas = document.getElementById('c1')
    const ctx = canvas.getContext('2d') // webgl绘制3d
    /*
      绘制饼图原理:
        1. 将数据算出比例
        2. 根据比例算出度数
        3. 将多个角度依次拼接，得到一个完整的饼图
    */
    // 假设这是后台数据
    const data = [
      { value: 300, color: 'green' },
      { value: 400, color: 'pink' },
      { value: 500, color: 'skyblue' },
      { value: 300, color: '#ccc' },
      { value: 400, color: '#000' },
    ]

    // 1. 先算出总数
    let total = data.reduce((p, c) => p + c.value, 0)

    // 2. 数据 / 总数 = 占比
    let data1 = data.map(item => {
      const scale = item.value / total
      return {
        ...item,
        scale
      }
    })

    // 3. 因为饼图最后会形成一个圆，一个圆为360°，所以我们根据占比来计算占的角度
    // 4. 下一个角的开始度数是上一个角的结束度数,初始我们假设从0开始
    let data2 = data1.reduce((p, c) => {
      // 下一个角的开始度数是上一个角的结束度数
      const startAngle = p[p.length - 1] ? p[p.length - 1].endAngle : 0
      // 计算出每一份数据应该占的角度
      const deg = 360 * c.scale
      p.push({
        ...c,
        startAngle,
        endAngle: deg + startAngle
      })
      return p
    }, [])
    const x = canvas.width, y = canvas.height, startAngle = 0, radius = 200

    // 画一个角度
    // ctx.beginPath()
    // ctx.moveTo(x / 2, y / 2)
    // // canvas中  圆的开始位置是从3点钟方向开始
    // ctx.arc(x / 2, y / 2, radius, 0, deg2arc(90))
    // ctx.fillStyle = 'red'
    // ctx.closePath()
    // ctx.fill()


    // 我们进行封装
    function drawDeg(x, y, radius, startAngle, endAngle, color) {
      // 路径操作一定要用beginPath来清空上一次的信息
      ctx.beginPath()
      ctx.moveTo(x, y)
      // canvas中  圆的开始位置是从3点钟方向开始
      ctx.arc(x, y, radius, deg2arc(startAngle), deg2arc(endAngle))
      ctx.fillStyle = color
      // 自动闭合路径
      ctx.closePath()
      ctx.fill()
    }

    // 将上面处理好的数据进行循环，然后调用我们封装的函数即可
    data2.forEach(item => {
      const { startAngle, endAngle, color } = item
      drawDeg(x / 2, y / 2, radius, startAngle, endAngle, color)
    })

    // 角度转弧度
    function deg2arc(deg) {
      /*
        360° = 2π
        1° = 2π / 360 = π / 180
        n° = n * (π / 180)
      */
      return deg * (Math.PI / 180)
    }
    // 弧度转角度
    function arc2deg(arc) {
      /*
        2π = 360°
        1弧度 = 360 / 2π =  180 / π
        n弧度 = n * (180 / π)
      */
      return arc * (180 / π)
    }

  </script>
</body>

</html>