{"version":3,"file":"reactivity.global.js","sources":["../../shared/src/index.ts","../src/effect.ts","../src/basehandles.ts","../src/reactive.ts","../src/ref.ts","../src/computed.ts"],"sourcesContent":["export const isObject = val => typeof val === 'object' && val !== null\r\nexport const extend = Object.assign\r\nexport const stringify = JSON.stringify\r\nexport const isArray = Array.isArray\r\nexport const IntegerKey = key => parseInt(key) + '' === key\r\nexport const isFunc = val => typeof val === 'function'\r\nexport const hasOwn = (target, key) => Object.prototype.hasOwnProperty.call(target, key)\r\nexport const hasChanged = (oldValue, value) => oldValue !== value\r\nexport const warn = (val) => console.warn(val)","import { isArray } from \"@vue/shared\"\r\nimport { TriggerTypes } from \"packages/shared/src/opeartors\"\r\n\r\n// effect(() =>{},{flush:'sync'}) 立即执行一次\r\nexport const effect = function (fn, options: any = {}) {\r\n  // 高阶函数返回新的effect函数\r\n  const effect = createReactiveEffect(fn, options)\r\n  if (!options.lazy) {\r\n    // 因为一上来就执行了一次，所以我们这里执行了effect调用就是相当于执行了createReactiveEffect中的effect函数\r\n    effect()\r\n  }\r\n  return effect\r\n}\r\nlet uid = 0, activeEffect, effectStack = []\r\nfunction createReactiveEffect(fn, options) {\r\n  const effect = function () {\r\n    /**\r\n     * 我们可能会写出这样的代码\r\n     * effect(() =>{  ---> effect1\r\n     *    state.name\r\n     *    effect(() =>{ ---> effect2\r\n     *         state.age\r\n     *    })\r\n     *    state.address\r\n     * })\r\n     * 当我们进行第一次取值state.name时,name和effect1进行关联\r\n     * 当我们进行第二次取值state.age时,age和effect2进行关联\r\n     * 但是当我们进行第三次取值state.address时,此时的address和effect2关联了,就不对了\r\n     * 因为effect的调用就是一个类似函数的调用栈，所以我们可以用一个栈形结构来维护key和effect的关系\r\n     * 我们调用用户的函数可能会发生异常\r\n     */\r\n    try {\r\n      effectStack.push(effect)\r\n      activeEffect = effect\r\n      // const fn = () => {\r\n      //   console.log(state.name + state.age)\r\n      // }\r\n      // effect(fn)\r\n      // 函数调用，会进行取值，我们需要收集对应的依赖关系，后续当状态发生改变，我们可以通知视图去更新，类似于Vue2中的 Dep / Watcher\r\n      // effect的返回值就是函数调用的返回值\r\n      // 取值走get\r\n      return fn()\r\n    } finally {\r\n      // 调用完函数从栈中抛出\r\n      effectStack.pop()\r\n      // 让我们下一个的effect指向正确的effect\r\n      activeEffect = effectStack[effectStack.length - 1]\r\n    }\r\n  }\r\n  effect.uid = uid++ // effect的唯一标识\r\n  effect._isEffect = true // 标识是否为响应式effect\r\n  effect.raw = fn // 将用户回调函数和effect做一个关联\r\n  effect.options = options // 储存用户的配置选项\r\n  return effect\r\n}\r\nlet targetMap = new WeakMap;\r\n/**\r\n * \r\n * @param target 目标对象\r\n * @param type 唯一标识\r\n * @param key 对象的key\r\n */\r\nexport function track(target, type, key) {\r\n  // 要将key和对应的effect进行关联，我们用一个全局变量\r\n  // 因为我们只有在effect中使用状态才会进行依赖收集,在外界使用我们是不管的,而每次get时都会触发此方法，所以我们需要判断一下activeEffect是否有值\r\n  // 有值就说明是在effect中使用的状态\r\n  if (activeEffect) {\r\n    // 我们需要将key和effect进行关联，而key也应该和对应的目标对象进行关联，effect可能有多个，也有可能会重复，所以这里的关系是这样的\r\n    // (WeakMap target) => (Map key => Set effect)\r\n    let depsMap = targetMap.get(target)\r\n    // 第一次WeakMap中肯定没有target目标对象\r\n    if (!depsMap) {\r\n      targetMap.set(target, (depsMap = new Map))\r\n    }\r\n    let deps = depsMap.get(key)\r\n    // 第一次Map中肯定没有key\r\n    if (!deps) {\r\n      depsMap.set(key, (deps = new Set))\r\n    }\r\n    // 第一次Set中肯定没有effect\r\n    if (!deps.has(key)) {\r\n      deps.add(activeEffect)\r\n    }\r\n    // 这样我们的关系就建立了,等到用户修改数据时，我们通知对应的effect重新执行即可\r\n  }\r\n}\r\n/**\r\n * \r\n * @param target 目标对象\r\n * @param type 标识是新增还是修改,0新增,1修改\r\n * @param key 要对哪个key进行操作\r\n * @param value 操作后的结果值\r\n * @param oldValue 操作前的结果值\r\n */\r\nexport function trigger(target, type, key, value?, oldValue?) {\r\n  // 如果没有收集过对应的依赖，那么是不需要进行更新的\r\n  const depsMap = targetMap.get(target)\r\n  if (!depsMap) return\r\n  // 用于存放要执行的effect函数集合\r\n  const effects = new Set\r\n  const add = (deps) => {\r\n    if (deps) {\r\n      deps.forEach(effect => effects.add(effect))\r\n    }\r\n  }\r\n  // 说明改的是数组的length\r\n  if (key === 'length' && isArray(target)) {\r\n    // 我们需要循环depsMap,将要执行的effect全部添加到容器中\r\n    depsMap.forEach((dep, key) => {\r\n      // key > value 是这种情况\r\n      /**\r\n       * const state = reactive({arr:[1,2,3]})\r\n      *  effect(() => console.log(state.arr[2]))\r\n      *  setTimeout(() =>{ state.arr.length = 1 },1000)\r\n      * 此时的key为2, value是1 ,也要进行更新\r\n       */\r\n      if (typeof key !== 'symbol') {\r\n        if (key === 'length' || key > value) {\r\n          add(dep)\r\n        }\r\n      }\r\n    })\r\n  } else {\r\n    // 对象\r\n    if (key !== undefined) {\r\n      add(depsMap.get(key))\r\n    }\r\n    // 如果修改数组中的某一个索引，也要更新\r\n    switch (type) {\r\n      case TriggerTypes.ADD:\r\n        // 表示是新增，通知length的effect去更新\r\n        add(depsMap.get('length'))\r\n    }\r\n  }\r\n  // 让effect更新\r\n  effects.forEach((effect: any) => {\r\n    if (effect.options.scheduler) {\r\n      return effect.options.scheduler()\r\n    }\r\n    return effect()\r\n  })\r\n}\r\n\r\n","import { extend, stringify, isObject, isArray, IntegerKey, hasOwn, hasChanged } from \"@vue/shared\"\r\nimport { readonly, reactive } from \"./reactive\"\r\nimport { OpeaTypes, TriggerTypes } from \"packages/shared/src/opeartors\"\r\nimport { track, trigger } from \"./effect\"\r\n\r\n/**\r\n * \r\n * @param readonly 是否为只读的，默认不是\r\n * @param shallow 是否为浅层的，默认不是\r\n */\r\nconst createGetter = function (isReadonly = false, shallow = false) {\r\n  // 真实的get函数，当读取代理对象中的值时，会触发此函数\r\n  /**\r\n   * @param target 目标对象\r\n   * @param property 被获取的属性名\r\n   * @param receiver 代理对象\r\n   */\r\n  return function get(target, property, receiver) {\r\n    const res = Reflect.get(target, property, receiver)\r\n    // 如果不是只读的，就说明要收集对应的依赖，因为只读的话不能被修改，所以不需要收集依赖，这些依赖后面会去更新我们对应的视图\r\n    if (!isReadonly) {\r\n      // 收集依赖...\r\n      track(target, OpeaTypes.GET, property)\r\n    }\r\n    // 如果是浅层代理，那么直接返回结果即可,不需要继续进行代理了\r\n    if (shallow) {\r\n      return res\r\n    }\r\n    // 如果取到的值还是一个对象,那么我们要递归进行代理\r\n    if (isObject(res)) {\r\n      // 看是否为只读的\r\n      return isReadonly ? readonly(res) : reactive(res)\r\n    }\r\n\r\n    return res\r\n  }\r\n}\r\nconst createSetter = function (shallow = false) {\r\n  /**\r\n   * @param target 目标对象\r\n   * @param property 被获取的属性名\r\n   * @param value 新属性值\r\n   * @param receiver 代理对象\r\n   */\r\n  return function set(target, property, value, receiver) {\r\n    // 拿到老值,后面实现watch的时候会用到\r\n    let oldValue = target[property]\r\n    // 判断是新增还是修改,可能是数组，可能是对象,因为reactive包裹的是一个对象\r\n    const hadKey = isArray(target) && IntegerKey(property)\r\n      ? Number(property) < target.length\r\n      : hasOwn(target, property)\r\n    const res = Reflect.set(target, property, value, receiver)\r\n    if (!hadKey) {\r\n      // 新增，可能是数组或者是对象\r\n      trigger(target, TriggerTypes.ADD, property, value)\r\n    } else if (hasChanged(oldValue, value)) {\r\n      // 修改, 可能是数组或者是对象\r\n      trigger(target, TriggerTypes.SET, property, value, oldValue)\r\n    }\r\n    return res\r\n  }\r\n}\r\nconst readonlyObj = {\r\n  set: function (target, key) {\r\n    console.warn(`set ${key} on ${stringify(target)} failed`)\r\n  }\r\n}\r\nexport const mutableHandles = {\r\n  get: createGetter(),\r\n  set: createSetter()\r\n}\r\nexport const shallowReactiveHandles = {\r\n  get: createGetter(false, true),\r\n  set: createSetter(true)\r\n}\r\nexport const readonlyHandles = extend({\r\n  get: createGetter(true, false),\r\n}, readonlyObj.set)\r\nexport const shallowReadonlyHandles = extend({\r\n  get: createGetter(true, true)\r\n}, readonlyObj.set)\r\n","import { mutableHandles, shallowReadonlyHandles, shallowReactiveHandles, readonlyHandles } from './basehandles'\r\nimport { isObject } from '@vue/shared'\r\n\r\n// 返回一个代理对象，深度代理，可修改\r\nexport function reactive(target) {\r\n  return createReactiveObject(target, false, mutableHandles)\r\n}\r\n// 返回一个代理对象，浅层代理，可修改\r\nexport function shallowReactive(target) {\r\n  return createReactiveObject(target, false, shallowReactiveHandles)\r\n}\r\n// 返回一个代理对象，深度代理，不可被修改\r\nexport function readonly(target) {\r\n  return createReactiveObject(target, true, shallowReadonlyHandles)\r\n}\r\n// 返回一个代理对象，浅层代理，未被代理的可以被修改\r\nexport function shallowReadonly(target) {\r\n  return createReactiveObject(target, true, readonlyHandles)\r\n}\r\nconst reactiveMap = new WeakMap;\r\nconst readonlyMap = new WeakMap;\r\n\r\n/**\r\n * \r\n * @param target 要被代理的对象\r\n * @param isReadOnly 是否为只读\r\n * @param handles proxy中的处理逻辑(get/set)\r\n */\r\nfunction createReactiveObject(target, isReadOnly, handles) {\r\n  // 如果要被代理的对象不是一个对象,那么返回原对象\r\n  if (!isObject(target)) return target\r\n  // 先从缓存中读取结果，如果已经被存过了，那么直接返回缓存的代理结果即可\r\n  const proxyMap = isReadOnly ? readonlyMap : reactiveMap\r\n  const isExitsProxy = proxyMap.get(target)\r\n  if (isExitsProxy) {\r\n    return isExitsProxy\r\n  }\r\n  // 对象如果被代理过，就不用再次代理，那么我们需要将代理过的结果缓存起来\r\n  const proxy = new Proxy(target, handles)\r\n  // 缓存代理结果，形成原目标和代理目标的映射关系\r\n  proxyMap.set(target, proxy)\r\n  // 返回代理对象\r\n  return proxy\r\n}","import { track, trigger } from \"./effect\"\r\nimport { TrackTypes } from \"packages/shared/src/opeartors\"\r\nimport { hasChanged, isArray } from \"@vue/shared\"\r\nimport { isObject } from \"@vue/shared\"\r\nimport { reactive } from \"./reactive\"\r\n\r\nfunction createRef(rawValue, shallow = false) {\r\n  return new RefImpl(rawValue, shallow)\r\n}\r\nconst convert = val => isObject(val) ? reactive(val) : val;\r\nclass RefImpl {\r\n  // 声明属性\r\n  public _v_isRef = true // 标识是一个ref属性\r\n  public _value\r\n  // 简写:相当于在内部 this.rawValue = rawValue;this.shallow = shallow\r\n  constructor(public rawValue, public shallow) {\r\n    // ref可以接收对象类型，如果接收的是对象类型，需要定义成响应式\r\n    this._value = shallow ? rawValue : convert(rawValue)\r\n  }\r\n  // 类的属性访问器，编译后为Object.defineProperty\r\n  get value() {\r\n    // 外界: let r = ref(''); \r\n    // 当外界去访问 r.value 时，要收集相关依赖 ==> track\r\n    // 当外界去设置 r.value 时，要通知更新 ==> trigger\r\n    // r.value 访问的是 this._value\r\n    // 这样我们使用r.value时，value就会和对应的effect进行关联\r\n    // 关联关系: RefImpl的实例 => value => [effect]\r\n    track(this, TrackTypes.GET, 'value')\r\n    return this._value\r\n  }\r\n  set value(newValue) {\r\n    // 通知更新\r\n    if (hasChanged(this.rawValue, newValue)) {\r\n      // 这次的新值当成下一次的老值\r\n      this._value = this.shallow ? newValue : convert(newValue)\r\n      this.rawValue = newValue\r\n      trigger(this, TrackTypes.SET, 'value', newValue, this.rawValue)\r\n    }\r\n  }\r\n}\r\nclass ObjectRefImpl {\r\n  public _v_isRef = true\r\n  constructor(public target, public key) {\r\n\r\n  }\r\n  get value() {\r\n    return this.target[this.key]\r\n  }\r\n  set value(newValue) {\r\n    this.target[this.key] = newValue\r\n  }\r\n}\r\nexport function ref(rawValue) {\r\n  return createRef(rawValue)\r\n}\r\nexport function shallowRef(rawValue) {\r\n  return createRef(rawValue, true)\r\n}\r\n// 将一个值包装成ref对象，是否为响应式取决于原来的值是否是响应式\r\nexport function toRef(target, key) {\r\n  return new ObjectRefImpl(target, key)\r\n}\r\n// 将多个值包装成ref对象，是否为响应式取决于原来的值是否是响应式\r\nexport function toRefs(target) {\r\n  // const r = toRefs(state)\r\n  // target可能是数组，可能是对象\r\n  const res = isArray(target) ? new Array(target.length) : {}\r\n  for (let key in target) {\r\n    res[key] = toRef(target, key)\r\n  }\r\n  return res\r\n}","import { isFunc, warn } from \"@vue/shared\"\r\nimport { effect, track, trigger } from \"./effect\"\r\nimport { TrackTypes } from \"packages/shared/src/opeartors\"\r\n\r\n/*\r\n      计算属性特点:\r\n        默认不会执行，当取值时才会执行\r\n        有缓存，如果状态没有发生变化，不会重新执行函数，会返回上一次值\r\n        可以传入一个函数，这个函数就是getter函数\r\n        也可以传入一个配置项，配置项中包含get和set\r\n        computed(() =>{})\r\n        computed({get(){},set(){}})\r\n*/\r\nexport function computed(getterOrOptions) {\r\n  let getter, setter\r\n  if (isFunc(getterOrOptions)) {\r\n    // 是函数的情况\r\n    getter = getterOrOptions\r\n    setter = () => warn('Write operation failed: computed value is readonly')\r\n  } else {\r\n    // 是配置项的情况\r\n    getter = getterOrOptions.get\r\n    setter = getterOrOptions.set\r\n  }\r\n  return new ComputedRefImpl(getter, setter)\r\n}\r\nclass ComputedRefImpl {\r\n  // 标识计算属性getter的返回值\r\n  public _value\r\n  // 标识是一个Ref\r\n  public _v_isRef = true\r\n  // 默认是脏的，通过此变量来控制是否需要缓存\r\n  public _dirty = true\r\n  public effect\r\n  constructor(public getter, public setter) {\r\n    // 默认getter不会执行,只有取值时才会执行\r\n    this.effect = effect(getter, {\r\n      lazy: true, // 默认不执行\r\n      scheduler: () => {\r\n        // 说明变化过\r\n        if (!this._dirty) {\r\n          this._dirty = true\r\n          // 通知更新\r\n          trigger(this, TrackTypes.SET, 'value')\r\n        }\r\n      }\r\n    })\r\n  }\r\n  /**\r\n   * 外界是这么访问的\r\n   * const state = reactive({age:10})\r\n   * const c = computed(() => state.age + 10)\r\n   * c.value ==> 20\r\n   */\r\n  // 当读取c.value时，要调用我们的getter函数，函数的返回值作为我们的_value值\r\n  get value() {\r\n    // 要看一下依赖是否变化过，依赖变化过我们的dirty变量就为false\r\n    // 计算属性中依赖的响应式数据如果发生变化了，当我们再次取值时会重新执行getter函数\r\n    // 那么我们需要收集getter中的依赖\r\n    if (this._dirty) {\r\n      // effect的返回值就是用户回调的返回值\r\n      this._value = this.effect()\r\n      // 缓存，下一次在取值就进入不到此判断中，会返回上一次的值\r\n      this._dirty = false\r\n    }\r\n    // 收集依赖\r\n    track(this, TrackTypes.GET, 'value')\r\n    return this._value\r\n  }\r\n  set value(newVal) {\r\n    this.setter(newVal)\r\n  }\r\n}"],"names":[],"mappings":"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"}